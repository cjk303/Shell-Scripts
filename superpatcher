#!/usr/bin/env python3
import paramiko, re, time, json, sys
import argparse
from datetime import datetime, timezone
from typing import List, Dict, Optional, Tuple

# ----------------- Utilities -----------------
def _strip_ansi(s: str) -> str:
    return re.sub(r"\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])", "", s or "")

def _exec_stream(client: paramiko.SSHClient, cmd: str, timeout: int=30,
                 stream: bool=False, get_pty: bool=False) -> Tuple[int,str,str]:
    stdin, stdout, stderr = client.exec_command(cmd, get_pty=get_pty, timeout=timeout)
    out = stdout.read().decode()
    err = stderr.read().decode()
    ec = stdout.channel.recv_exit_status()
    return ec, out, err

def _exec_sudo(client: paramiko.SSHClient, cmd: str, sudo_password: str,
               timeout: int=30, stream: bool=False, get_pty: bool=False) -> Tuple[int,str,str]:
    full_cmd = f"sudo -S -p '' {cmd}"
    ec, out, err = _exec_stream(client, full_cmd, timeout=timeout, stream=stream, get_pty=get_pty)
    return ec, out, err

def is_root(client: paramiko.SSHClient) -> bool:
    ec, out, _ = _exec_stream(client, "id -u")
    return out.strip() == "0"

def detect_platform(client: paramiko.SSHClient) -> str:
    ec, out, _ = _exec_stream(client, "grep '^ID=' /etc/os-release || true")
    m = re.search(r'ID=(\w+)', out or "")
    if m:
        return m.group(1).lower()
    return "unknown"

def connect(host: str, user: str, password: str, port: int, timeout: int) -> paramiko.SSHClient:
    client = paramiko.SSHClient()
    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    client.connect(hostname=host, username=user, password=password, port=port, timeout=timeout)
    return client

def _remote_time_iso(client: paramiko.SSHClient) -> str:
    ec, out, _ = _exec_stream(client, "date -u +%Y-%m-%dT%H:%M:%SZ")
    return out.strip() if ec==0 else datetime.utcnow().isoformat()+'Z'

def _host_info(client: paramiko.SSHClient) -> dict:
    info = {}
    ec, out, _ = _exec_stream(client, "hostname")
    info["hostname"] = out.strip() if ec==0 else "unknown"
    ec, out, _ = _exec_stream(client, "uname -r")
    info["kernel"] = out.strip() if ec==0 else "unknown"
    return info

# ----------------- DNF helpers -----------------
DNF_LIST_CMD_NOREFRESH = "dnf list --updates"
DNF_LIST_CMD_REFRESH = "dnf --refresh list --updates"
DNF_UPGRADE_CMD = "dnf -y upgrade"
DNF_UPGRADE_TEST_CMD = "dnf -y upgrade --setopt=tsflags=test"

def list_updates_dnf(client: paramiko.SSHClient, refresh: bool, use_sudo: bool, timeout: int,
                     sudo_password: Optional[str]=None, require_pty: bool=False) -> int:
    cmd = DNF_LIST_CMD_REFRESH if refresh else DNF_LIST_CMD_NOREFRESH
    if use_sudo:
        ec, out, err = _exec_sudo(client, cmd, sudo_password or "", timeout=timeout, get_pty=require_pty)
    else:
        ec, out, err = _exec_stream(client, cmd, timeout=timeout, get_pty=False)
    if ec not in (0,100):
        raise RuntimeError(f"dnf list --updates failed (exit={ec}): {err or out}")
    count = len([l for l in _strip_ansi(out).splitlines() if l and not l.startswith("Updated Packages")])
    return count

def planned_upgrade_actions_dnf(client: paramiko.SSHClient, use_sudo: bool, timeout: int,
                                sudo_password: Optional[str]=None, require_pty: bool=False) -> int:
    cmd = DNF_UPGRADE_TEST_CMD
    if use_sudo:
        ec, out, err = _exec_sudo(client, cmd, sudo_password or "", timeout=timeout, get_pty=require_pty)
    else:
        ec, out, err = _exec_stream(client, cmd, timeout=timeout, get_pty=False)
    actions = 0
    for line in _strip_ansi(out).splitlines():
        if re.match(r"^(Upgrading|Installing|Reinstalling|Downgrading|Removing)\s", line, re.I):
            actions += 1
    return actions

def upgrade_dnf(client: paramiko.SSHClient, use_sudo: bool, timeout: int, stream: bool,
                sudo_password: Optional[str]=None, require_pty: bool=False) -> Tuple[str,str]:
    cmd = DNF_UPGRADE_CMD
    if use_sudo:
        ec, out, err = _exec_sudo(client, cmd, sudo_password or "", timeout=timeout, stream=stream, get_pty=require_pty)
    else:
        ec, out, err = _exec_stream(client, cmd, timeout=timeout, stream=stream, get_pty=False)
    if ec != 0:
        raise RuntimeError(f"dnf upgrade failed (exit={ec}): {err or out}")
    return out, err

def history_last(client: paramiko.SSHClient, use_sudo: bool=True, timeout: int=30,
                 sudo_password: Optional[str]=None, require_pty: bool=False) -> dict:
    cmd = "dnf history info last -q"
    if use_sudo:
        ec, out, err = _exec_sudo(client, cmd, sudo_password or "", timeout=timeout, get_pty=require_pty)
    else:
        ec, out, err = _exec_stream(client, cmd, timeout=timeout)
    if ec != 0:
        raise RuntimeError("dnf history info last failed")
    # Parse into dict
    packages=[]
    for line in _strip_ansi(out).splitlines():
        m = re.match(r"^\s*(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s*$", line)
        if m:
            packages.append({"name": m.group(1), "action": m.group(2), "old_version": m.group(3),
                             "new_version": m.group(4), "repo": ""})
    return {"packages": packages}

def _build_changed_packages_from_dnf(history: dict) -> List[Dict[str, str]]:
    changed=[]
    for pkg in history.get("packages", []):
        changed.append({
            "action": pkg.get("action","Unknown"),
            "name": pkg.get("name",""),
            "old": pkg.get("old_version",""),
            "new": pkg.get("new_version",""),
            "repo": pkg.get("repo","")
        })
    return changed

# ----------------- APT helpers -----------------
APT_INST_RX = re.compile(r"^Inst\s+([A-Za-z0-9+_.:-]+)(?:\s+\[([^\]]+)\])?\s+\(([^)]+)\s")

def _apt_normalize_name(name: str) -> str:
    return name.split(":",1)[0]

def _parse_apt_simulation(out: str) -> List[Dict[str,str]]:
    changes=[]
    for line in _strip_ansi(out).splitlines():
        line=line.strip()
        m = APT_INST_RX.match(line)
        if not m:
            continue
        name = _apt_normalize_name(m.group(1))
        old = (m.group(2) or "").strip()
        new = (m.group(3) or "").strip()
        if old:
            changes.append({"action":"Upgrade","name":name,"old":old,"new":new,"repo":""})
        else:
            changes.append({"action":"Install","name":name,"old":"","new":new,"repo":""})
    return changes

APT_UPDATED_ONCE=False
APT_UPDATE_CMD="apt-get update -qq"
APT_SIMULATE_UPGRADE="apt-get -s dist-upgrade"
APT_UPGRADE_CMD="apt-get -y dist-upgrade"

def _apt_update(client: paramiko.SSHClient, use_sudo: bool, sudo_password: Optional[str], timeout: int) -> bool:
    global APT_UPDATED_ONCE
    if APT_UPDATED_ONCE: return True
    cmd = f"bash -lc 'export DEBIAN_FRONTEND=noninteractive; {APT_UPDATE_CMD}'"
    if use_sudo:
        ec, out, err = _exec_sudo(client, cmd, sudo_password or "", timeout=timeout)
    else:
        ec, out, err = _exec_stream(client, cmd, timeout=timeout)
    APT_UPDATED_ONCE = (ec==0)
    return APT_UPDATED_ONCE

def _apt_simulate(client: paramiko.SSHClient, use_sudo: bool, sudo_password: Optional[str], timeout: int) -> List[Dict[str,str]]:
    _apt_update(client, use_sudo, sudo_password, timeout)
    cmd=f"bash -lc 'export DEBIAN_FRONTEND=noninteractive; {APT_SIMULATE_UPGRADE}'"
    ec, out, err = _exec_stream(client, cmd, timeout=timeout)
    return _parse_apt_simulation(out or "")

def _apt_upgrade(client: paramiko.SSHClient, use_sudo: bool, sudo_password: Optional[str], timeout: int) -> Tuple[str,str,int]:
    before = _apt_simulate(client, use_sudo=False, sudo_password=sudo_password, timeout=timeout)
    _apt_update(client, use_sudo, sudo_password, timeout)
    cmd=f"bash -lc 'export DEBIAN_FRONTEND=noninteractive; {APT_UPGRADE_CMD}'"
    if use_sudo:
        ec, out, err = _exec_sudo(client, cmd, sudo_password or "", timeout=timeout)
    else:
        ec, out, err = _exec_stream(client, cmd, timeout=timeout)
    after = _apt_simulate(client, use_sudo=False, sudo_password=sudo_password, timeout=timeout)
    changed = _apt_diff_before_after(before, after)
    return out, err, len(changed)

def _apt_diff_before_after(before: List[Dict[str,str]], after: List[Dict[str,str]]) -> List[Dict[str,str]]:
    changed=[]
    after_map={p["name"]:p for p in after}
    for b in before:
        a = after_map.get(b["name"])
        if a:
            changed.append({"action":"Upgrade","name":b["name"],"old":b.get("new",""),"new":a.get("new",""),"repo":""})
        else:
            changed.append({"action":b.get("action","Install"),"name":b["name"],"old":"","new":b.get("new",""),"repo":""})
    for a in after:
        if a["name"] not in {b["name"] for b in before}:
            changed.append({"action":"Install","name":a["name"],"old":"","new":a.get("new",""),"repo":""})
    return changed

# ----------------- Reboot checks -----------------
def reboot_required(client: paramiko.SSHClient, platform: str, use_sudo: bool, sudo_password: Optional[str], timeout: int) -> bool:
    if platform=="rhel":
        cmd="needs-restarting -r"
        if use_sudo:
            ec, out, _ = _exec_sudo(client, cmd, sudo_password or "", timeout=timeout)
        else:
            ec, out, _ = _exec_stream(client, cmd, timeout=timeout)
        return ec==1
    else:
        cmd="[ -f /var/run/reboot-required ] && echo yes || echo no"
        if use_sudo:
            ec, out, _ = _exec_sudo(client, cmd, sudo_password or "", timeout=timeout)
        else:
            ec, out, _ = _exec_stream(client, cmd, timeout=timeout)
        return _strip_ansi(out).strip()=="yes"

# ----------------- Summary -----------------
def _only_upgraded_pairs(changed: List[Dict[str,str]]) -> List[Dict[str,str]]:
    return sorted([c for c in changed if c.get("action")=="Upgrade" and c.get("old") and c.get("new")], key=lambda x:x["name"])

def _print_summary(changed_packages: List[Dict[str,str]], reboot_performed: bool, fmt="text"):
    upgraded = _only_upgraded_pairs(changed_packages)
    summary = {"upgraded_count": len(upgraded), "reboot_performed": reboot_performed, "reboot_success": reboot_performed}
    if fmt=="json":
        print(json.dumps(summary))
    else:
        print(f"Upgraded packages: {summary['upgraded_count']} | Reboot performed: {'YES' if reboot_performed else 'NO'}")

# ----------------- Main CLI -----------------
def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("host"); parser.add_argument("username"); parser.add_argument("password")
    parser.add_argument("--port",type=int,default=22); parser.add_argument("--timeout",type=int,default=30)
    parser.add_argument("--upgrade-timeout",type=int,default=1800)
    parser.add_argument("--sudo",action="store_true"); parser.add_argument("--upgrade",action="store_true")
    parser.add_argument("--dry-run",action="store_true")
    parser.add_argument("--reboot",action="store_true")
    parser.add_argument("--summary-only",action="store_true")
    parser.add_argument("--json",action="store_true")
    args=parser.parse_args()

    client = connect(args.host, args.username, args.password, args.port, args.timeout)
    session_is_root = is_root(client)
    use_sudo = args.sudo or not session_is_root

    platform = detect_platform(client)
    report = {"changed_packages":[]}

    if platform=="rhel":
        if args.dry_run:
            _ = planned_upgrade_actions_dnf(client, use_sudo, args.timeout)
        hx = history_last(client, use_sudo, args.timeout, args.password)
        report["changed_packages"] = _build_changed_packages_from_dnf(hx)
        if args.upgrade:
            upgrade_dnf(client, use_sudo, args.upgrade_timeout, stream=False, sudo_password=args.password)
    else:
        before = _apt_simulate(client, use_sudo=False, sudo_password=args.password, timeout=args.timeout)
        if args.upgrade:
            _apt_upgrade(client, use_sudo, sudo_password=args.password, timeout=args.upgrade_timeout)
        after = _apt_simulate(client, use_sudo=False, sudo_password=args.password, timeout=args.timeout)
        report["changed_packages"] = _apt_diff_before_after(before, after)

    reboot_needed = reboot_required(client, platform, use_sudo, args.password, args.timeout)

    if args.summary_only:
        _print_summary(report["changed_packages"], reboot_performed=reboot_needed, fmt="json" if args.json else "text")
    else:
        print(json.dumps(report, indent=2) if not args.json else json.dumps(report))

if __name__=="__main__":
    main()
